<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core</name>
    </assembly>
    <members>
        <member name="T:VL.App.AppHost`1">
            <summary>
            Encapsulates all the platform independent logic to run a VL app.
            </summary>
        </member>
        <member name="P:VL.Core.IAppHost.OnExit">
            <summary>
            Raided when the application exits.
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.TryDisguise``1(VL.Core.ITrackedVLObject)">
            <summary>
            COMPILER ONLY. This method should only get called for explicit interface implementations. 
            We don't check for outdated in some cases, as this is done inside the to be called method already
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.TryDisguiseInputMaybeAnything``1(System.Object)">
            <summary>
            You can call this when you are not sure if you want to trigger a restore and let the user decide.
            This also makes sure that users don't run into follow up issues of an incomplete hotswap, like null pointer exceptions. 
            Even when the user patched everything correctly.
            The alternative is the very cheap Self operation, which is also will prevent the user from nightmare debugging wher a restart solves the issue.
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.TryDisguiseInputMaybeAnything``1(VL.Core.ITrackedVLObject)">
            <summary>
            You can call this when you are not sure if you want to trigger a restore and let the user decide.
            This also makes sure that users don't run into follow up issues of an incomplete hotswap, like null pointer exceptions. 
            Even when the user patched everything correctly.
            The alternative is the very cheap Self operation, which is also will prevent the user from nightmare debugging wher a restart solves the issue.
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.Self(System.Object)">
            <summary>
            This will give you a hand onto a restore object if there is any. 
            This also makes sure that users don't run into follow up issues of an incomplete hotswap. 
            Restarts before the user can when something doesn't match anymore.
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.Self(VL.Core.ITrackedVLObject)">
            <summary>
            This will give you a hand onto a restore object if there is any. 
            This also makes sure that users don't run into follow up issues of an incomplete hotswap. 
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.ShieldedDisposeCatchingAllExceptions(System.Object)">
            <summary>
            Turns off restoring fields and any restore related exceptions.
            Also swallows all other exceptions. We use this in order to shut down the old object as thoroughly as possible.
            Used in different places of the hotswap system. Used by HDE to shutdown tooltips. Used in Runtime to stop ignorant.
            </summary>
        </member>
        <member name="M:VL.Core.CompilationHelper.ShieldedDisposeForManagedFields(System.Object)">
            <summary>
            Shielding Dispose call from hotswap algorithm. 
            Used in target code making sure that normal exceptions do get reported.
            </summary>
        </member>
        <member name="P:VL.Core.CompilerServices.AdaptiveImplementationsAttribute.TargetType">
            <summary>
            The struct which carries the implementations.
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.AdaptiveTypeAttribute">
            <summary>
            For example used on Particle&lt;T&gt; pointing to Particle&lt;T, AdC&gt;
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.CollectionBuilders">
            <summary>
            These builders are used by the target code for pin groups and ouput splicers.
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.PrivateImplAttribute">
            <summary>
            Gets attached to private VL object implementations.
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.SerializedDefaultValueAttribute">
            <summary>
            Attached to parameters to encode the default value.
            </summary>
        </member>
        <member name="T:VL.Core.PublicAPI.ICustomRegionPatch">
            <summary>
            This represents the user patch inside the region
            You may create and manage several patch states by calling CreateRegionPatch
            </summary>
        </member>
        <member name="M:VL.Core.PublicAPI.ICustomRegionPatch.Update(System.Collections.Generic.IReadOnlyList{System.Object},VL.Lib.Collections.Spread{System.Object}@,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            Updates the patch state by calling what the user patched
            If the context is immutable it will return a new instance of the type when necessary
            </summary>
            <param name="inputs">The inputs from the inside perspective</param>
            <param name="incomingLinks">The values traveling along the links that cross the region boundaries. If you don't connect anything it will autoconnect to CustomRegion.IncomingLinkValues.</param>
            <param name="outputs">The outputs from the inside perspective</param>
            <returns></returns>
        </member>
        <member name="T:VL.Core.PublicAPI.ICustomRegion">
            <summary>
            Represents the application of your region by the user, the values that flow into the region and outof. 
            It also allows you to instanciate what's inside: the patch of the user. 
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.Inputs">
            <summary>
            The inputs from an outside perspective
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.Outputs">
            <summary>
            The outputs from an outside perspective
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.IncomingLinks">
            <summary>
            Incoming links that cross the region boundaries
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.InputValues">
            <summary>
            Retrieves the untouched inputs. 
            Your region might want to change some values before feeding it to the patch.
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.OutputValues">
            <summary>
            After updating the custom region patch and altering the values you finally need to write the outputs.
            These may be different from the values that you got from the patch update call.
            </summary>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.IncomingLinkValues">
            <summary>
            These are the values that travel along links that cross the region boundaries. 
            </summary>
        </member>
        <member name="M:VL.Core.PublicAPI.ICustomRegion.CreateRegionPatch(VL.Core.NodeContext,System.Collections.Generic.IReadOnlyList{System.Object},VL.Lib.Collections.Spread{System.Object}@)">
            <summary>
            Create a patch state
            </summary>
            <param name="Context"></param>
            <param name="initialInputs"></param>
            <param name="initialOutputs"></param>
            <returns></returns>
        </member>
        <member name="P:VL.Core.PublicAPI.ICustomRegion.PatchHasChanged">
            <summary>
            Happens when users are patching or on fresh start
            </summary>
        </member>
        <member name="P:VL.Core.CustomRegion.CustomRegionAttribute.NodeOrRegionChoice">
            <summary>
            Allows to customize whether the region can also be created as a node.
            </summary>
        </member>
        <member name="P:VL.Core.CustomRegion.CustomRegionAttribute.SupportedBorderControlPoints">
            <summary>
            What control points the region shall support.
            </summary>
        </member>
        <member name="P:VL.Core.CustomRegion.CustomRegionAttribute.TypeConstraint">
            <summary>
            The type constraint to apply on the control points. 
            In case of splicers the system will try to align the inner type (e.g. float) with the inner most argument (and also right most) of the outer (e.g. Spread{float} or Dictionary{string, float}).
            </summary>
        </member>
        <member name="M:VL.Core.Documentation.GetEventInfosWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the events with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the events of.</param>
            <returns>The IEnumerable of the events with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetConstructorInfosWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the constructors with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the constructors of.</param>
            <returns>The IEnumerable of the constructors with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetPropertyInfosWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the properties with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the properties of.</param>
            <returns>The IEnumerable of the properties with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetFieldInfosWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the fields with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the fields of.</param>
            <returns>The IEnumerable of the fields with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetMethodInfosWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the methods with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the methods of.</param>
            <returns>The IEnumerable of the methods with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetTypesWithAttribute``1(System.Reflection.Assembly)">
            <summary>Enumerates through all the types with a custom attribute.</summary>
            <typeparam name="AttributeType">The type of the custom attribute.</typeparam>
            <param name="assembly">The assembly to iterate through the types of.</param>
            <returns>The IEnumerable of the types with the provided attribute type.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetDerivedTypes``1(System.Reflection.Assembly)">
            <summary>Gets all the types in an assembly that derive from a base.</summary>
            <typeparam name="Base">The base type to get the deriving types of.</typeparam>
            <param name="assembly">The assmebly to perform the search on.</param>
            <returns>The IEnumerable of the types that derive from the provided base.</returns>
        </member>
        <member name="M:VL.Core.Documentation.GetDirectoryPath(System.Reflection.Assembly)">
            <summary>Gets the file path of an assembly.</summary>
            <param name="assembly">The assembly to get the file path of.</param>
            <returns>The file path of the assembly.</returns>
        </member>
        <member name="M:VL.Core.Documentation.ClearXmlDocumentation">
            <summary>Clears the currently loaded XML documentation.</summary>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Type)">
            <summary>Gets the XML documentation on a type.</summary>
            <param name="type">The type to get the XML documentation of.</param>
            <returns>The XML documentation on the type.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.MethodInfo)">
            <summary>Gets the XML documentation on a method.</summary>
            <param name="methodInfo">The method to get the XML documentation of.</param>
            <returns>The XML documentation on the method.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.ConstructorInfo)">
            <summary>Gets the XML documentation on a constructor.</summary>
            <param name="constructorInfo">The constructor to get the XML documentation of.</param>
            <returns>The XML documentation on the constructor.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.PropertyInfo)">
            <summary>Gets the XML documentation on a property.</summary>
            <param name="propertyInfo">The property to get the XML documentation of.</param>
            <returns>The XML documentation on the property.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.FieldInfo)">
            <summary>Gets the XML documentation on a field.</summary>
            <param name="fieldInfo">The field to get the XML documentation of.</param>
            <returns>The XML documentation on the field.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.EventInfo)">
            <summary>Gets the XML documentation on an event.</summary>
            <param name="eventInfo">The event to get the XML documentation of.</param>
            <returns>The XML documentation on the event.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.MemberInfo)">
            <summary>Gets the XML documentation on a member.</summary>
            <param name="memberInfo">The member to get the XML documentation of.</param>
            <returns>The XML documentation on the member.</returns>
            <remarks>The XML documentation must be loaded into memory for this function to work.</remarks>
        </member>
        <member name="M:VL.Core.Documentation.GetDocumentation(System.Reflection.ParameterInfo)">
            <summary>Gets the XML documentation for a parameter.</summary>
            <param name="parameterInfo">The parameter to get the XML documentation for.</param>
            <returns>The XML documenation of the parameter.</returns>
        </member>
        <member name="P:VL.Core.ElementAttribute.TracingId">
            <summary>
            The element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.DocumentId">
            <summary>
            The document id.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.PersistentId">
            <summary>
            The persistent element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsAutoGenerated">
            <summary>
            Whether or not the element was auto generated by the compiler.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsManaged">
            <summary>
            Whether or not the field will be disposed when it goes out of scope during a hotswap.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.Name">
            <summary>
            The name of the element. This is set in case the compiler generated name differs from the one set in VL.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.NodeName">
            <summary>
            The name of the node description which lead to this element. Used by dynamic nodes during hot swap.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.NodeCategory">
            <summary>
            The category of the node description which lead to this element. Used by dynamic nodes during hot swap.
            </summary>
        </member>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.SwappableVLObject`1.__Restore``1">
            <summary>
            This gets called from every taget code method with TStateClass being the State object of the program
            </summary>
        </member>
        <member name="P:VL.Core.TypeTracker.LatestTypeDefinition">
            <summary>
            Particle'1
            </summary>
        </member>
        <member name="P:VL.Core.TypeTracker.LatestProgramDefinition">
            <summary>
            ParticleProgram'2 (AdC is the second)
            </summary>
        </member>
        <member name="F:VL.Core.VLObjectProgram.Instantiations">
            <summary>
            Keeps track of all instantiations which occur during runtime.
            </summary>
        </member>
        <member name="T:VL.Core.InitializationException">
            <summary>
            Thrown in case initialization code fails.
            </summary>
        </member>
        <member name="T:VL.Core.IInfo">
            <summary>
            Implement this interface to provide a summary and remarks.
            </summary>
        </member>
        <member name="P:VL.Core.IInfo.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="P:VL.Core.IInfo.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="T:VL.Core.ITaggedInfo">
            <summary>
            Implement this interface to provide tags the node browser can use to find stuff.
            </summary>
        </member>
        <member name="P:VL.Core.ITaggedInfo.Tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescriptionFactory">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="M:VL.Core.IVLNodeDescriptionFactory.Export(VL.Core.ExportContext)">
            <summary>
            Allows the node factory to take part in the export process. Gets invoked for each node factory directly referenced by the project.
            The invocations will be in build order. 
            Use <see cref="P:VL.Core.ExportContext.SolutionWideStorage"/> to store information across the whole export process.
            </summary>
            <param name="exportContext">The export context of the current project.</param>
        </member>
        <member name="P:VL.Core.ExportContext.ProjectRootElement">
            <summary>
            The Microsoft.Build.Construction.ProjectRootElement which represent the MSBuild project.
            The property is typed as object to avoid a runtime dependency on MSBuild.
            Should the factory code do indeed need to interact with the project it needs to ensure that
            the method doing the cast will trigger a type load exception should MSBuild not be present (for example if a patch was exported).
            For details see https://github.com/microsoft/MSBuildLocator
            </summary>
        </member>
        <member name="P:VL.Core.ExportContext.DirectoryPath">
            <summary>
            The directory that the project being generated is in.
            </summary>
        </member>
        <member name="P:VL.Core.ExportContext.SolutionWideStorage">
            <summary>
            A dictionary whose lifetime is tied to the generation of the whole solution.
            Can be used to store information whether or not certain tasks (like copying files from a directory) have already been done.
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="P:VL.Core.IVLNodeDescription.Fragmented">
            <summary>
            Whether the system shall create getter and setter fragments for each pin. 
            The first getter will also be marked as the default fragment.
            </summary>
        </member>
        <member name="T:VL.Core.IVLPinDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLNode">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPin">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPin`1">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="P:VL.Core.IPathProvider.AppBasePath">
            <summary>
            The base path of the currently running application.
            </summary>
        </member>
        <member name="M:VL.Core.IPathProvider.GetDocumentBasePath(VL.Core.UniqueId)">
            <summary>
            The document base path. Running inside the editor this refers to the directory of the document otherwise the directory of the executable.
            </summary>
        </member>
        <member name="M:VL.Core.PathProviderUtils.GetApplicationBasePath(VL.Core.NodeContext)">
            <summary>
            Retrieves the base path of the current application. In case of a running patch it's the base path of the entry point.
            </summary>
            <param name="nodeContext">The node context to retrieve the entry point from.</param>
            <returns>The base path of the application.</returns>
        </member>
        <member name="M:VL.Core.PathProviderUtils.GetApplicationBasePath">
            <summary>
            Retrieves the base path of the current application. In case of a running patch it's the base path of the entry point.
            </summary>
            <returns>The base path of the application.</returns>
        </member>
        <member name="M:VL.Core.PathProviderUtils.GetDocumentBasePath(VL.Core.NodeContext)">
            <summary>
            Retrieves the base path of the current document.
            </summary>
            <param name="nodeContext">The node context to retrieve the current document from.</param>
            <returns>The base path of the current document.</returns>
        </member>
        <member name="T:VL.Core.IVLObject">
            <summary>
            Non-generic interface implemented by VL emitted classes and records.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Services">
            <summary>
            The service registry which was current when this instance was created.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Context">
            <summary>
            The context in which this instance was created.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Type">
            <summary>
            The type of the object.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Identity">
            <summary>
            The unique identity of the object. Gets preserved for immutable types.
            </summary>
        </member>
        <member name="T:VL.Core.IVLRuntime">
            <summary>
            Interface to interact with the VL runtime.
            </summary>
        </member>
        <member name="P:VL.Core.IVLRuntime.IsRunning">
            <summary>
            Whether or not VL is in a running state. If not calls into its object graph are not allowed.
            </summary>
        </member>
        <member name="M:VL.Core.IVLRuntime.ReportException(System.Exception)">
            <summary>
            Report an exception to the runtime. If possible the responsible nodes will be colored pink by the patch editor.
            </summary>
            <param name="exception">The exception to report.</param>
        </member>
        <member name="T:VL.Core.IVLFactory">
            <summary>
            Interface to create VL objects.
            </summary>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeByName(System.String)">
            <summary>
            Lookup a type by name. The name will be parsed based on the usual VL type annotation rules.
            For example "Integer32" or "Spread [Collections] &lt;Float32&gt;".
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The first type which matches the name or null.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeInfo(System.Type)">
            <summary>
            Fetch the VL type info for a given CLR type.
            </summary>
            <param name="type">The CLR type to fetch the VL type info for.</param>
            <returns>The VL type info wrapping the given CLR type.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.CreateInstance(System.Type,VL.Core.NodeContext)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="type">The type to create a new instance of.</param>
            <param name="nodeContext">The context to use when creating the instance.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetDefaultValue(System.Type)">
            <summary>
            Returns the default value of the given type as defined by VL through the CreateDefault operations.
            </summary>
            <param name="type">The type to return the default value of.</param>
            <returns>The default value of the given type as defined by VL or null if the type is not known to VL or no default has been defined.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.RegisterService(System.Type,System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a factory function which gets invoked when a certain service of type <paramref name="serviceType"/> is requested for
            a specific value of type <paramref name="forType"/>. The factory function must return a service of the specified <paramref name="serviceType"/>.
            </summary>
            <param name="forType">The type of the value for which a service will be requested.</param>
            <param name="serviceType">The type of the service.</param>
            <param name="serviceFactory">The factory function creating such a service.</param>
        </member>
        <member name="M:VL.Core.IVLFactory.GetServiceFactory(System.Type,System.Type)">
            <summary>
            Retrieves the factory function which will create the service of type <paramref name="serviceType"/> for the given <paramref name="forType"/>.
            </summary>
            <param name="forType">The type of the value for which a service is requested.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>The factory function creating the service or null.</returns>
        </member>
        <member name="T:VL.Core.IVLTypeInfo">
            <summary>
            Interface to interact with VL types.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Category">
            <summary>
            The category of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.FullName">
            <summary>
            The full name of the type. For example "Integer32 [Primitive]" or "Spread [Collections] &lt;Float32 [Primitive]&gt;".
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.ClrType">
            <summary>
            The CLR type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsPatched">
            <summary>
            Whether or not this type is a patched VL type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsClass">
            <summary>
            Whether or not this type is a VL class (mutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsRecord">
            <summary>
            Whether or not this type is a VL record (immutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsInterface">
            <summary>
            Whether or not this type is an interface.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Properties">
            <summary>
            The user defined properties of this type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.AllProperties">
            <summary>
            The user defined and system generated properties of this type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetProperty(System.String)">
            <summary>
            Returns the property with the given name.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The property or null.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.ToString(System.Boolean)">
            <summary>
            Returns a string representation of this type.
            </summary>
            <param name="includeCategory">Whether or not to include the category.</param>
            <returns>The string representation of this type.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.CreateInstance(VL.Core.NodeContext)">
            <summary>
            Create a new instance of this type by calling it's constructor using default values for any of its arguments.
            If there's no default constructor registered for this type it will fallback to the default value.
            </summary>
            <param name="context">The node context to use. Used by patched types.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetDefaultValue">
            <summary>
            Retrieves the default value of this type. 
            If there's no default value registered for this type it will return the CLR default.
            </summary>
            <returns>The default of this type.</returns>
        </member>
        <member name="T:VL.Core.IVLPropertyInfo">
            <summary>
            Interface to interact with VL properties.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DeclaringType">
            <summary>
            The type which declared this property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Id">
            <summary>
            The id of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Name">
            <summary>
            The name of the property. Special characters are escaped.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.OriginalName">
            <summary>
            The original property name. All characters are allowed.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Type">
            <summary>
            The type of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.IsManaged">
            <summary>
            Whether or not the property is system generated.
            </summary>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.GetValue(VL.Core.IVLObject)">
            <summary>
            Gets the property value of the given instance.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <returns>The value of the property.</returns>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.WithValue(VL.Core.IVLObject,System.Object)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <param name="instance">The instance to set the value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the newly set value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetDefaultValue``1(VL.Core.IVLFactory)">
            <summary>
            Returns the VL defined default value for the given type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type for which to return the VL defined default value.</typeparam>
            <param name="factory">The factory to use to create the default value.</param>
            <returns>The VL defined default value of the given type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateInstance``1(VL.Core.IVLFactory,``0,VL.Core.NodeContext,``0@)">
            <summary>
            Tries to create an instance of the given type <typeparamref name="T"/> using the VL generated constructor.
            Returns true in case an instance was created.
            </summary>
            <typeparam name="T">The type of which to create an instance for.</typeparam>
            <param name="factory">The factory which will create the instance.</param>
            <param name="defaultValue">The default value to use in case an instance couldn't be created.</param>
            <param name="nodeContext">The context in which the new instance will be created.</param>
            <param name="instance">The newly created instance or the given default value.</param>
            <returns>True in case a new instance was created.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type,VL.Core.UniqueId)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo,VL.Core.UniqueId)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``2(VL.Core.IVLFactory,System.Func{``0,``1})">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested for
            a value of type <typeparamref name="TForType"/>.
            </summary>
            <typeparam name="TForType">The type of the value for which a service will be requested.</typeparam>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="create">The factory function to invoke when such a service is requested.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``1(VL.Core.IVLFactory,``0)">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="service">The service to register.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateService``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetService``1(VL.Core.IVLFactory)">
            <summary>
            Gets the service type <typeparamref name="TService"/> or null.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which contains the service.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateServiceSafe``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value. returns default if creating the service failed.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateService``1(VL.Core.IVLFactory,System.Object,System.Type,``0,``0@)">
            <summary>
            Tries to create a service of the given type <typeparamref name="TService"/> for the given value.
            Returns true if such a service was found for the given value, otherwise the given default service will be used.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value which will be passed to the service constructor.</param>
            <param name="forType">The type for which to create the service for. If null the type of the value will be used.</param>
            <param name="defaultService">The default service to use in case no service of that type was registered for the type of the value.</param>
            <param name="service">The registered service or the given default service.</param>
            <returns>True in case a service was found and created.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetPath(VL.Core.IVLObject,VL.Core.IVLObject,System.String@)">
            <summary>
            Tries to retrieve the path from the instance to the descendant.
            </summary>
            <remarks>
            The function does a depth first search into the object tree given by the instance. 
            It will traverse all user defined properties which are either a VL object or a collection of VL objects.
            The supported collection types are spreads and dictionaries.
            </remarks>
            <param name="instance">The instance from where the search shall start.</param>
            <param name="descendant">The descendant to look for.</param>
            <param name="path">The path from the instance to the descendant.</param>
            <returns>True if the descendant was found.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValue``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given property.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The instance to retrieve the value from.</param>
            <param name="name">The name of the property.</param>
            <param name="defaultValue">The default value to use in case retrieval failed.</param>
            <param name="value">The returned values.</param>
            <returns>True if the retrieval succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValue``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given property and returns a new instance (if it is a record) with the set value.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="instance">The instance to set the property value on.</param>
            <param name="name">The name of the property.</param>
            <param name="value">The value to set.</param>
            <returns>The new instance (if it is a record) with the set value.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValueByPath``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" retrieves the first value in MySpread.</param>
            <param name="defaultValue">The default value to use in case the lookup failed.</param>
            <param name="value">The returned value.</param>
            <returns>True if the lookup succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValueByPath``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" sets the first value in MySpread.</param>
            <param name="value">The value to set.</param>
            <returns>The new root instance (if it is a record) with the updated spine.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.IsSupportedCollectionType(VL.Core.IVLTypeInfo)">
            <summary>
            Whether or not the type is supported by <see cref="M:VL.Core.VLObjectExtensions.TryReplaceDescendant``2(``0,``1,``0@)"/>.
            </summary>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryReplaceDescendant``2(``0,``1,``0@)">
            <summary>
            Traverses into the object graph of <paramref name="instance"/> and if it can find a descendant with the same <see cref="P:VL.Core.IVLObject.Identity"/>
            as the given <paramref name="descendant"/> replaces it and outputs a new <paramref name="updatedInstance"/>.
            </summary>
            <remarks>
            Only user defined properties will be traversed. If a property holds many children it must be of type <see cref="T:VL.Lib.Collections.ISpread"/> or <see cref="T:System.Collections.IDictionary"/>. Other collection types will not be looked at.
            </remarks>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TDescendant">The type of the descendant.</typeparam>
            <param name="instance">The instance to traverse into.</param>
            <param name="descendant">The new descendant.</param>
            <param name="updatedInstance">The updated instance with the descendant replaced.</param>
            <returns>Returns true if a descendant with the same <see cref="P:VL.Core.IVLObject.Identity"/> as the given one was found and replaced.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.TryGetValue``1(VL.Core.IVLPropertyInfo,VL.Core.IVLObject,``0,``0@)">
            <summary>
            Tries to get the property value of the given instance.
            </summary>
            <typeparam name="T">The expected type of the property value.</typeparam>
            <param name="property">The property to read.</param>
            <param name="instance">The instance to get the property value from.</param>
            <param name="defaultValue">The value to return in case retrieval failed.</param>
            <param name="value">The retrieved property value.</param>
            <returns>Whether or not the operation succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.WithValue``2(VL.Core.IVLPropertyInfo,``0,``1)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="property">The property to write.</param>
            <param name="instance">The instance to set the property value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the set value.</returns>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.Interval">
            <summary>
            Gets or sets the desired interval. This is the minimum time that has to pass between two frame ticks.
            Default is 1/60 of a second.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:VL.Core.IMainLoopTimer.WaitAccuracy" -->
        <member name="P:VL.Core.IMainLoopTimer.IsIncremental">
            <summary>
            Enables fixed increment time mode.
            </summary>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.Increment">
            <summary>
            Gets or sets the time increment. Used when <see cref="P:VL.Core.IMainLoopTimer.IsIncremental"/> is set to true.
            </summary>
        </member>
        <member name="P:VL.Core.IMainLoopTimer.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="E:VL.Core.IMainLoopTimer.Tick">
            <summary>
            Occurs when the Timer has completed one interval.
            </summary>
        </member>
        <member name="T:VL.Core.PreciseMainLoopTimer">
            <summary>
            Timer using the busy wait method on a new thread, extremely accurate but uses a bit of CPU.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.#ctor">
            <summary>
            Initializes a new instance of the Timer class.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Interval">
            <summary>
            Gets or sets the time between Tick events.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Mode">
            <summary>
            Gets or sets the timer mode.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Increment">
            <summary>
            Gets or sets the time increment. Used when <see cref="P:VL.Core.PreciseMainLoopTimer.IsIncremental"/> is set to true.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.IsRunning">
            <summary>
            Gets a value indicating whether the Timer is running.
            </summary>
        </member>
        <member name="E:VL.Core.PreciseMainLoopTimer.Tick">
            <summary>
            Occurs when the Timer has completed one interval.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Start">
            <summary>
            Starts the timer.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Stop">
            <summary>
            Stops timer.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Dispose">
            <summary>
            Frees timer resources.
            </summary>
        </member>
        <member name="T:VL.Core.TimerMode">
            <summary>
            Defines constants for the Timer's event types
            </summary>
        </member>
        <member name="F:VL.Core.TimerMode.OneShot">
            <summary>
            Timer event occurs once.
            </summary>
        </member>
        <member name="F:VL.Core.TimerMode.Periodic">
            <summary>
            Timer event occurs periodically.
            </summary>
        </member>
        <member name="T:VL.Core.TimeSpanUtils">
            <summary>
            Creates TimeSpans in a precise way, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromMillisecondsPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromSecondsPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.TimeSpanUtils.FromMinutesPrecise(System.Double)">
            <summary>
            Creates a TimeSpan with precise tick count, normal "From" methods do weird rounding.
            </summary>
        </member>
        <member name="M:VL.Core.WindowsMessageUtils.DoEvents">
            <summary>
            Process all messages in the queue.
            </summary>
            <returns>True if the WM_QUIT or WM_DESTROY message occured</returns>
        </member>
        <member name="T:VL.Core.WindowsTimerUtils">
            <summary>
            Description of WinApiCalls.
            </summary>
        </member>
        <member name="T:VL.Core.MonadicAttribute">
            <summary>
            Marks a type as monadic - it can wrap any basic type. The value wrapping is done through an intermediate as specified by the given factory.
            </summary>
        </member>
        <member name="T:VL.Core.IMonadicFactory`2">
            <summary>
            Implementations must have a default constructor as well as a static readonly field called "Default".
            </summary>
            <typeparam name="TValue">The type of the value</typeparam>
            <typeparam name="TMonad">The type of the monadic value</typeparam>
        </member>
        <member name="M:VL.Core.IMonadicFactory`2.GetMonadBuilder(System.Boolean)">
            <summary>
            Creates a monad builder.
            </summary>
            <param name="isConstant">Whether or not the value is constant.</param>
            <returns>The monad builder</returns>
        </member>
        <member name="T:VL.Core.IMonadBuilder`2">
            <summary>
            Builds the monadic value <typeparamref name="TMonad"/> out of <typeparamref name="TValue"/>.
            </summary>
            <typeparam name="TValue">The type of the value</typeparam>
            <typeparam name="TMonad">The type of the monadic value</typeparam>
        </member>
        <member name="T:VL.Core.NodeContext">
            <summary>
            Contains information about the environment in which a node was created.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.Create(VL.Core.UniqueId)">
            <summary>
            Creates a new root context.
            </summary>
            <returns>The new root context.</returns>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Collections.Immutable.ImmutableStack{VL.Core.UniqueId},System.Boolean)">
            <summary>
            Creates a new context.
            </summary>
            <param name="path">The path to the node for which this context gets created.</param>
            <param name="isImmutable">Whether the context must be immutable.</param>
        </member>
        <member name="F:VL.Core.NodeContext.Path">
            <summary>
            The path to the node.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.IsImmutable">
            <summary>
            Whether or not the context is immutable. In an immutable context the state must not be modified.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.CreateSubContext(System.String,System.String,System.UInt32)">
            <summary>
            Creates a new sub context.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.CreateSubContext(VL.Core.UniqueId)">
            <summary>
            Creates a new sub context.
            </summary>
        </member>
        <member name="P:VL.Core.NodeContext.FrameClock">
            <summary>
            The frame clock.
            </summary>
        </member>
        <member name="P:VL.Core.NodeContext.RealTimeClock">
            <summary>
            The real time clock.
            </summary>
        </member>
        <member name="P:VL.Core.NodeFactoryRegistry.Paths">
            <summary>
            The registered paths. Each registered node factory can produce additional factories per path.
            </summary>
        </member>
        <member name="M:VL.Core.PatchHandle.#ctor(System.UInt32)">
            <summary>
            We only know of the patch. No node path, no object identity available
            </summary>
        </member>
        <member name="M:VL.Core.PatchHandle.#ctor(VL.Core.NodePath)">
            <summary>
            That's already quite nice! We know the node path, but no object identity available
            </summary>
        </member>
        <member name="T:VL.Core.RuntimeGraph">
            <summary>
            A collection of methods used by nodes which introduce new entry points into the VL runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.ReportException(System.Exception)">
            <summary>
            The exception to throw by the HandleAsyncException call.
            </summary>
            <param name="exception">The exception to report.</param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.ReportException(System.Exception,VL.Core.ServiceRegistry)">
            <summary>
            The exception to throw by the HandleAsyncException call.
            </summary>
            <param name="exception">The exception to report.</param>
            <param name="capturedServiceRegistry">The captured service registry.</param>
        </member>
        <member name="T:VL.Core.ISerializer`1">
            <summary>
            The serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.ISerializer`1.Serialize(VL.Core.SerializationContext,`0)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.ISerializer`1.Deserialize(VL.Core.SerializationContext,System.Object,System.Type)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="T:VL.Core.SerializationContext">
            <summary>
            The serialization context.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.#ctor(VL.Core.NodeContext,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a new serialization context.
            </summary>
            <param name="nodeContext">The node context.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="version">The version of the serialization format.</param>
        </member>
        <member name="P:VL.Core.SerializationContext.Version">
            <summary>
            The version of the serialization format.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.ThrowOnError">
            <summary>
            Whether or not serialization error should lead to an exception
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.IncludeDefaults">
            <summary>
            Whether or not default values will also be serialized.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Errors">
            <summary>
            The accumulated error messages.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Services">
            <summary>
            The service provider.
            </summary>
        </member>
        <member name="F:VL.Core.SerializationContext.NodeContext">
            <summary>
            The node context of the object currently being serialized. Used to resolve paths.
            </summary>
        </member>
        <member name="F:VL.Core.SerializationContext.TypeRegistry">
            <summary>
            The type registry used to map .NET types to VL types.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.ReportError(System.String)">
            <summary>
            Reports an error. Will throw a <see cref="T:VL.Core.SerializationException"/> in case <see cref="P:VL.Core.SerializationContext.ThrowOnError"/> is enabled.
            </summary>
            <param name="message">The error message to report.</param>
        </member>
        <member name="M:VL.Core.SerializationContext.GetTagName(System.Type)">
            <summary>
            Returns the name of the type without any generic type parameter suffixes and replaces [] with Array.
            </summary>
        </member>
        <member name="T:VL.Core.SerializationException">
            <summary>
            Represents errors that occur during serialization.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationException.#ctor(System.String)">
            <summary>
            Creates a new instances of the <see cref="T:VL.Core.SerializationException"/> class with the specified error message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:VL.Core.Serialization">
            <summary>
            Serialization related extension methods and constants.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.ReflectionNamespace">
            <summary>
            The reflection namespace.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.TypeAttributeName">
            <summary>
            The name of the type attribute.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.VersionAttributeName">
            <summary>
            The name of the version attribute.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializer``2(VL.Core.IVLFactory,``1)">
            <summary>
            Registers a VL serializer to the factory. 
            In case the type for which the serializer gets registered is generic a dummy type instantiation paired with a dummy
            serializer instantiation containing a public default constructor has to be registered. For example a serializer implementation
            of type FooSerializer&lt;T&gt; for the generic type Foo&lt;T&gt; has to be registered for the dummy instantiaton Foo&lt;object&gt;.
            </summary>
            <typeparam name="TForType">The type for which to register a serializer.</typeparam>
            <typeparam name="TSerializer">The type of the serializer implementation.</typeparam>
            <param name="factory">The factory in which the serializer gets registered.</param>
            <param name="serializer">The serializer to register.</param>
            <returns>The factory with the registered serializer.</returns>
        </member>
        <member name="M:VL.Core.Serialization.CanSerialize(VL.Core.IVLFactory,System.Type)">
            <summary>
            Whether or not an instance of the given type can be serialized.
            </summary>
            <param name="factory">The factory containing the serializer registrations.</param>
            <param name="forType">The type of the instance to serialize.</param>
            <returns>True if an instance of the given type can be serialized.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.SerializationContext,System.String,``0,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </typeparam>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize(VL.Core.SerializationContext,System.String,System.Object,System.Type,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="staticType">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.SerializationContext,System.Object,System.String)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize(VL.Core.SerializationContext,System.Object,System.String,System.Type)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="staticType">The statically known type of the value to deserialize.</param>
            <returns>The deserialized value or the default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.CollectionSerializer`2">
            <summary>
            The abstract base class to use when writing a VL serializer for a collection type.
            </summary>
            <typeparam name="TElement">The element type of the collection.</typeparam>
            <typeparam name="TCollection">The type of the collection.</typeparam>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.NodeContext,``0,System.Boolean)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case serialization fails.</remarks>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="nodeContext">The node context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="includeDefaults">Whether or not default values should be serialized.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.NodeContext,``0,System.Boolean,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="nodeContext">The node context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.NodeContext,System.Xml.Linq.XElement)">
            <summary>
            Deserializes the given content.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case deserialization fails.</remarks>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="nodeContext">The node context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.NodeContext,System.Xml.Linq.XElement,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Deserializes the given content.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="nodeContext">The node context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="throwOnError">Whether or not deserialization errors should lead to an exception.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializers(VL.Core.IVLFactory)">
            <summary>
            Registers all the default serializers in the factory.
            </summary>
            <param name="factory">The factory to register in.</param>
        </member>
        <member name="M:VL.Core.Serialization.GetSerializer(VL.Core.IVLFactory,System.Type)">
            <summary>
            Gets a serializer for the given type.
            </summary>
            <param name="factory">The factory to fetch the serializer from.</param>
            <param name="forType">The type for which a serializer has to be fetched.</param>
            <returns>The serializer or null in case no serializer is registered for that type.</returns>
        </member>
        <member name="T:VL.Core.Serialization.Serializer">
            <summary>
            The non-generic serializer class.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Serialize(VL.Core.SerializationContext,System.Object)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized value as <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Deserialize(VL.Core.SerializationContext,System.Object,System.Type)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <returns>The deserialized value or the default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.UngenericDelegatingSerializer`1">
            <summary>
            Bridge to user implemented generic serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="T:VL.Core.ServiceRegistry">
            <summary>
            Provides services for the whole application (<see cref="P:VL.Core.ServiceRegistry.Global"/>) or to a specific call stack (<see cref="P:VL.Core.ServiceRegistry.Current"/>).
            All entry points (runtime instances, editor extensions, exported apps) will make a registry current before calling into the patch (<see cref="M:VL.Core.ServiceRegistry.MakeCurrent"/>).
            Patches will capture the current service registry and restore it in callbacks should no other registry be current (<see cref="M:VL.Core.ServiceRegistry.MakeCurrentIfNone"/>).
            </summary>
        </member>
        <member name="P:VL.Core.ServiceRegistry.Current">
            <summary>
            The service registry for the current thread. Throws <see cref="T:System.InvalidOperationException"/> in case no registry is installed.
            </summary>
        </member>
        <member name="P:VL.Core.ServiceRegistry.CurrentOrGlobal">
            <summary>
            The service registry for the current thread or the global one if no there's no registry installed on the current thread.
            </summary>
        </member>
        <member name="P:VL.Core.ServiceRegistry.Global">
            <summary>
            The service registry for the whole application.
            </summary>
        </member>
        <member name="M:VL.Core.ServiceRegistry.IsCurrent">
            <summary>
            Whether or not a context is installed on the current thread.
            </summary>
        </member>
        <member name="M:VL.Core.ServiceRegistry.MakeCurrent">
            <summary>
            Make the registry current on the current thread.
            </summary>
            <returns>A subscription which will restore the previous registry on dispose.</returns>
        </member>
        <member name="M:VL.Core.ServiceRegistry.MakeCurrentIfNone">
            <summary>
            Make the registry current on the current thread if no registry is current yet.
            </summary>
            <returns>A subscription which will restore the previous registry on dispose.</returns>
        </member>
        <member name="M:VL.Core.SingleAppInstanceUtils.GetOrAddAppMutex(System.String,System.Boolean@,System.Boolean)">
            <summary>
            Tries to create a mutex with given name. Also sets the static OtherInstanceIsRunning property.
            </summary>
            <param name="mutexName">Name of the mutex.</param>
            <param name="isNew">True if the mutex was created, false if another instance exists already</param>
            <param name="addGlobalPrefix">If set to <c>true</c> the "Global\" prefis is added.</param>
            <returns>
            The new or existing mutex.
            </returns>
        </member>
        <member name="T:VL.Core.IHasMemory`1">
            <summary>
            Allows to get access to the backing <see cref="T:System.ReadOnlyMemory`1"/> or <see cref="T:System.Memory`1"/> of the implementing class.
            </summary>
            <remarks>
            Currently implemented by <see cref="T:VL.Lib.Collections.Spread`1" /> and <see cref="T:VL.Lib.Collections.SpreadBuilder`1"/>
            </remarks>
            <typeparam name="T">The elment type.</typeparam>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.Memory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.Memory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.Memory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.Memory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.ReadOnlyMemory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.ReadOnlyMemory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Empty``1">
            <summary>
            Returns empty memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <returns>The empty memory.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.HasData``1(VL.Core.IHasMemory{``0})">
            <summary>
            Wether or not not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>True if not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Length``1(VL.Core.IHasMemory{``0})">
            <summary>
            The length in elements of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The length of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Size``1(VL.Core.IHasMemory{``0})">
            <summary>
            The size in bytes of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size in bytes of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.ElementSize``1(VL.Core.IHasMemory{``0})">
            <summary>
            Returns the size in bytes of one element of the memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size of one element in bytes.</returns>
        </member>
        <member name="T:VL.Core.Optional`1">
            <summary>
            Represents an optional value. Use HasValue to test whether a value is present.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="P:VL.Core.Optional`1.Value">
            <summary>
            The actual value.
            </summary>
        </member>
        <member name="P:VL.Core.Optional`1.HasValue">
            <summary>
            Whether or not a value is present.
            </summary>
        </member>
        <member name="P:VL.Core.Optional`1.HasNoValue">
            <summary>
            Whether or not the value is missing.
            </summary>
        </member>
        <member name="M:VL.Core.TypeUtils.New(System.Type,VL.Core.NodeContext)">
            <summary>
            Creates a new instance of the specified type.
            </summary>
        </member>
        <member name="M:VL.Core.TypeUtils.New``1(VL.Core.NodeContext)">
            <summary>
            Creates a new instance of the specified type.
            </summary>
        </member>
        <member name="M:VL.Core.TypeUtils.Default(System.Type)">
            <summary>
            Returns the default value as defined by VL.
            </summary>
        </member>
        <member name="M:VL.Core.TypeUtils.Default``1">
            <summary>
            Returns the default value as defined by VL.
            </summary>
        </member>
        <member name="M:VL.Core.TypeUtils.MakeGenericAdaptiveType(System.Type,System.Type[])">
            <summary>
            Same as MakeGenericType but taking adaptive node parameters into account.
            </summary>
            <param name="type">The generic type defintion. Can be the public type (Particle&lt;T&gt;) or the private type (Particle&lt;T, AdC&gt;)</param>
            <param name="arguments">The generic arguments.</param>
            <returns>The fully instantiated private type for e.g. Particle&lt;float, __SOME_STRUCT__&gt;</returns>
            <exception cref="T:System.InvalidOperationException">If no adaptive implementation struct was found.</exception>
            <remarks>
            This method currently fails if the provided arguments lead to adaptive instantiations which haven't been seen by the compiler.
            We therefor keep the method internal for now.
            </remarks>
        </member>
        <member name="T:VL.Core.UniqueId">
            <summary>
            A unique and persistent identifier for a patch element. 
            It consists of the persistent/serialized id of the element as well as the persistent/serialized id of the document where the element resides in.
            </summary>
        </member>
        <member name="P:VL.Core.UniqueId.VolatileId">
            <summary>
            Only valid while the session is running. Used by some obsolete APIs.
            </summary>
        </member>
        <member name="P:VL.Core.VersionUtils.IsPreview">
            <summary>
            Whether or not this is a preview build.
            </summary>
        </member>
        <member name="P:VL.Core.VersionUtils.FullVersionString">
            <summary>
            The full version string. e.g. "2019.1.0" or "2019.1.0-0063-g2b0be431ff" for preview
            </summary>
        </member>
        <member name="M:VL.Core.VersionUtils.InformationalVersionToUserVersion(System.String)">
            <summary>
            Parses an informational preview version to user version. e.g. "2019.1.0-63+g2b0be431ff" to "2019.1.0-0063-g2b0be431ff".
            Release version will be returned without change, e.g. "2019.1.0"
            </summary>
        </member>
        <member name="M:VL.Core.VersionUtils.ParseLanguageVersion(System.String)">
            <summary>
            Parses the LanguageVersion attribute of documents to a version. 
            Handles strings like "2019.1.0" or "2019.1.0-0063-g2b0be431ff" or "2019.1.0-roslyn.763-g631ba19afb" or "2019.1.0-763.roslyn-g631ba19afb"
            </summary>
        </member>
        <member name="T:VL.Core.MapMode">
            <summary>
            vvvv like modi for the Map function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Float">
            <summary>
            Maps the value continously
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Clamp">
            <summary>
            Maps the value, but clamps it at the min/max borders of the output range
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Wrap">
            <summary>
            Maps the value, but repeats it into the min/max range, like a modulo function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Mirror">
            <summary>
            Maps the value, but mirrors it into the min/max range, always against either start or end, whatever is closer
            </summary>
        </member>
        <member name="T:VL.Core.VLMath">
            <summary>
            The vvvv c# math routines library
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.Pi">
            <summary>
            Pi, as you know it
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPi">
            <summary>
            Pi * 2
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.PiRez">
            <summary>
            1 / Pi, multiply by this if you have to divide by Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPiRez">
            <summary>
            2 / Pi, multiply by this if you have to divide by 2*Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToRad">
            <summary>
            Conversion factor from cycles to radians, (2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToCyc">
            <summary>
            Conversion factor from radians to cycles, 1/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToRad">
            <summary>
            Conversion factor from degree to radians, (2 * Pi)/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToDeg">
            <summary>
            Conversion factor from radians to degree, 360/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToCyc">
            <summary>
            Conversion factor from degree to radians, 1/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToDeg">
            <summary>
            Conversion factor from radians to degree, 360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.IdentityMatrix">
            <summary>
            Identity matrix 
            1000 
            0100
            0010
            0001
            </summary>
        </member>
        <member name="M:VL.Core.VLMath.Factorial(System.Int32)">
            <summary>
            Factorial function, DON'T FEED ME WITH LARGE NUMBERS !!! (n>10 can be huge)
            </summary>
            <param name="n"></param>
            <returns>The product n * n-1 * n-2 * n-3 * .. * 3 * 2 * 1</returns>
        </member>
        <member name="M:VL.Core.VLMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Binomial function
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns>The number of k-tuples of n items</returns>
        </member>
        <member name="M:VL.Core.VLMath.Pow(System.Single,System.Int32)">
            <summary>
            Raises x to the power of y.
            </summary>
            <param name="x">The base.</param>
            <param name="y">The exponent.</param>
            <returns>Returns x raised to the power of y.</returns>
            <remarks>This method should be considerably faster than Math.Pow for small y.</remarks>
        </member>
        <member name="M:VL.Core.VLMath.SolveQuadratic(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Solves a quadratic equation a*x^2 + b*x + c for x
            </summary>
            <param name="a">Coefficient of x^2</param>
            <param name="b">Coefficient of x</param>
            <param name="c">Constant</param>
            <param name="x1">First solution</param>
            <param name="x2">Second solution</param>
            <returns>Number of solution, 0, 1, 2 or int.MaxValue</returns>
        </member>
        <member name="M:VL.Core.VLMath.Min(System.Single,System.Single)">
            <summary>
            Min function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Smaller value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Max(System.Single,System.Single)">
            <summary>
            Max function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Greater value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Zmod(System.Int32,System.Int32)">
            <summary>
            Modulo function with the property, that the remainder of a division z / d
            and z &lt; 0 is positive. For example: zmod(-2, 30) = 28.
            </summary>
            <param name="z"></param>
            <param name="d"></param>
            <returns>Remainder of division z / d.</returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamp function, clamps an integer value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int64,System.Int64,System.Int64)">
            <summary>
            Clamp function, clamps a long value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector2,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector3,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector4,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(System.Single)">
            <summary>
            Abs function for values, just for completeness
            </summary>
            <param name="a"></param>
            <returns>New value with the absolut value of a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector2)">
            <summary>
            Abs function for 2d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector3)">
            <summary>
            Abs function for 3d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(Stride.Core.Mathematics.Vector4)">
            <summary>
            Abs function for 4d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Ratio(System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            This Method can be seen as an inverse of Lerp (in Mode Float). Additionally it provides the infamous Mapping Modes, author: velcrome
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="start">Minimum of input value range</param>
            <param name="end">Maximum of input value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(System.Single,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for values
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector2,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector3,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector4,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,Stride.Core.Mathematics.Vector2,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,Stride.Core.Mathematics.Vector3,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,Stride.Core.Mathematics.Vector4,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation (blending) between two values
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[ or a if x = 0 or b if x = 1</returns>
        </member>
        <member name="F:VL.Core.VLObject.WithMethodName">
            <summary>
            The name of the auto generated With method used to update the fields.
            </summary>
        </member>
        <member name="P:VL.Core.VLFactory.Current">
            <summary>
            Returns the VL factory installed on the current thread.
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameTimeMessage.Time">
            <summary>
            The frame time since application start
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameTimeMessage.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.Time">
            <summary>
            The frame time since application start
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.FrameDuration">
            <summary>
            The elapsed time since the current frame has started
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameFinishedMessage.LastInterval">
            <summary>
            The time interval between the last frame and the current frame.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.IFrameClock.TimeDifference">
            <summary>
            Gets the time difference between the frame time of the last frame to the current frame time.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.IFrameClock.GetTicks">
            <summary>
            Gets an observable that sends an event before each frame.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.IFrameClock.GetFrameFinished">
            <summary>
            Gets an observable that sends an event directly after the Update call of each frame.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Clocks.SetCurrentFrameClock(VL.Lib.Animation.IFrameClock)">
            <summary>
            Sets the clock for the current thread.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.FrameClock">
            <summary>
            The clock used to determine the time when the current frame of the vl mainloop started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentFrameTime">
            <summary>
            The time when the current frame started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.RealTimeClock">
            <summary>
            The clock used to determine the current time, returns a new time value for each call
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentTime">
            <summary>
            Checks time now
            </summary>
        </member>
        <member name="F:VL.Lib.Animation.FrameClock.MinTimeDifferenceInSeconds">
            <summary>
            One micro second. Minimal time difference of frame clock, avoids DivideByZero exceptions in animation nodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.FrameClock.SetFrameTime(VL.Lib.Animation.Time)">
            <summary>
            Used on start of the frame, sets the frame time and triggers the before frame tick event.
            </summary>
            <param name="frameTime">The absolute time since start. Global parameter used by the animation nodes</param>
        </member>
        <member name="M:VL.Lib.Animation.FrameClock.NotifyFrameFinished">
            <summary>
            Used immediately after the frame work is done, sets the frame duration time and triggers the frame finished event.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.DesiredTimeDifference">
            <summary>
            Desired interval time in seconds, also used to initialize the time difference on first frame and restart.
            Defalt is 1/60.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.IsIncremental">
            <summary>
            Enables fixed increment time mode.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.TimeIncrement">
            <summary>
            Desired increment time in seconds, used if <see cref="P:VL.Lib.Animation.FrameClock.IsIncremental"/> is set to true;
            Defalt is 1/60.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.WaitAccuracy">
            <summary>
            Estimated precision of the accuracy of Sleep(1) on the current machine in seconds.
            Default is 0.002s (2ms). Usually between 1ms and 16ms. Higher values make the timer more precise but uses more CPU power.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.FrameClock.Elapsed">
            <summary>
            The elapsed time since start as TimeSpan, setting the property will call SetFrameTime and update the clock variables.
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTime(System.DateTime)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTimeUTC(System.DateTimeOffset)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Reactive.HoldLatestCopy`2">
            <summary>
            Holds on to a copy of the latest received data. Whenever data gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="T:VL.Lib.Reactive.Monadic.ChannelBuilder`1">
            <summary>
            Part of infrastructure to support connecting <typeparamref name="T"/> to <see cref="T:VL.Lib.Reactive.Channel`1"/>
            </summary>
        </member>
        <member name="T:VL.Lib.Reactive.Monadic.ChannelFactory`1">
            <summary>
            Part of infrastructure to support connecting <typeparamref name="T"/> to <see cref="T:VL.Lib.Reactive.Channel`1"/>
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareAdded">
            <summary>
            Checks for device additions, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareRemoved">
            <summary>
            Checks for device removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareChanged">
            <summary>
            Checks for device additions and removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="F:VL.Lib.HardwareChangedEvents.WaitForInstallationTimeoutInMilliseconds">
            <summary>
            The wait for installation timeout in milliseconds, defaults to 1 minute
            </summary>
        </member>
        <member name="T:VL.Lib.GUID_DEVCLASS">
            <summary>
             Defines GUIDs for device classes used in Plug &amp; Play.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ArrayBuilder`1">
            <summary>
            Allows to build up arrays in an efficient way.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the builder.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the builder.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.ElementAtOrDefault(System.Int32)">
            <summary>
            Gets the element at the specified index in the builder or the default value if the index is out of range.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the builder or the default value if the index is out of range.</returns>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Count">
            <summary>
            The amount of items currently stored in the builder.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Capacity">
            <summary>
            The capacity of the builder.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.ArrayBuilder`1.Buffer">
            <summary>
            Gives access to the internally used array. The length of the returned array might be greater then the item count of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsSpan">
            <summary>
            Exposes the content of the builder as a <see cref="T:System.Span`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsMemory">
            <summary>
            Exposes the content of the builder as <see cref="T:System.Memory`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArraySegment">
            <summary>
            Exposes the content of the builder as <see cref="T:System.ArraySegment`1"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArray">
            <summary>
            Resizes the internal array to the count of the builder and returns it.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AsArray(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns the upstream sequence as an array. This can be done efficiently without copying for immutable collections based on arrays like
            <see cref="T:VL.Lib.Collections.Spread`1"/> or <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>. For other collection types the content will be copied into
            the internal array and returned.
            </summary>
            <param name="items">The upstream sequence.</param>
            <returns>The array from the upstream immutable array based collection or the internal array containing the content.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Add(`0)">
            <summary>
            Add an item to the builder.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.UncheckedAdd(`0)">
            <summary>
            Add an item to the builder without checking whether the capacity is large enough. Use only if capacity is large enough.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of items to the builder. The sequence will be checked for well known collection types in order to do the copying efficiently.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.ReadOnlySpan{`0}@)">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(`0[])">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.AddRange(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds the items to the builder.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Clear">
            <summary>
            Clears the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the current contents to the specified array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="index">The starting index of the target array.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Remove(`0)">
            <summary>
            Removes the specified element.
            </summary>
            <param name="element">The element.</param>
            <returns>A value indicating whether the specified element was found and removed from the collection.</returns>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Reverse">
            <summary>
            Reverses the order of elements in the collection.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort">
            <summary>
            Sorts the array.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="comparer">The comparer to use in sorting.</param>
        </member>
        <member name="M:VL.Lib.Collections.ArrayBuilder`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="index">The index of the first element to consider in the sort.</param>
            <param name="count">The number of elements to include in the sort.</param>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Value">
            <summary>
            Gets the current enum value as string
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Tag">
            <summary>
            Gets the associated tag if the enum definition has registered one.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnum.CreateValue(System.String)">
            <summary>
            Creates a new enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Default">
            <summary>
            Creates the default enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Definition">
            <summary>
            Gets the definition of this enum with all entries
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.OnChange">
            <summary>
            Fires when the definition changes, i.e. entries get added or removed
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.Entries">
            <summary>
            Gets the current list of valid entries
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnumDefinition.IsValid(System.String)">
            <summary>
            Returns true if the string is a valid entry of this enum type
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.EmptyEnumFallbackMessage">
            <summary>
            Gets the empty enum fallback string for cases when no entries are in the enum definition.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.IsValid(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Returns true if the value is in the current entry list of the definition.
            </summary>
            <returns>
              <c>true</c> if the specified input is valid, not null and its value is not a null or empty string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.SelectedIndex(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Gets the index of the selected item in the entries list of its definition.
            Can return -1 if the string is not in the current list of entries.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.CreateValue``1(``0,System.String)">
            <summary>
            Creates a new enum value of given type
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.TrySelectIndex``1(``0,System.Int32,System.Boolean@,``0@)">
            <summary>
            Sets the selected item to the value at the index in the entries list of its definition.
            If the index is out of range, returns false and the input value.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumBase`2">
            <summary>
            Base class for easy dynamic enum implementaion. Use like this:
            MyEnumClass : DynamicEnumBase&lt;MyEnumClass&gt; and override 
            IDynamicEnumDefinition Definition { get; } and define a default value:
            public static MidiInputDevice Default => new MyEnumClass("Default Entry");
            <typeparam name="TSubclass">The type of the actual dynamic enum class.</typeparam>
            <typeparam name="TDefinitionClass">The type of the enum definition.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnum" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumBase`2.CreateDefaultBase(System.String)">
            <summary>
            Can be used in subclass to create the default, selects the first entry.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.AnyDynamicEnumDefinitionChanged">
            <summary>
            Static class used to inform the compiler that a dynamic enum definition has changed
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumDefinitionBase`1">
            <summary>
            Base class for dynamic enum definitions.
            Takes care of the singleton pattern and the update of the entries. Use like this:
            MyEnumDefinitionClass : DynamicEnumBase&lt;MyEnumDefinitionClass&gt; and override the two abstract methods.
            <typeparam name="TDefinitionSubclass">The type of the actual definition class.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnumDefinition" />
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpread">
            <summary>
            Non-generic spread interface.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.AsMemory">
            <summary>
            Creates a new read-only memory region over this spread.
            </summary>
            <returns>The read-only memory representation of this spread.</returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.AsSpan">
            <summary>
            Creates a new read-only span region over this spread.
            </summary>
            <returns>The read-only span representation of this spread.</returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.ToBuilder">
            <summary>
            Creates a spread builder with the same contents as this spread that can be efficiently modified across multiple operations
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.IsEmpty">
            <summary>
            Whether or not the spread is empty
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Count">
            <summary>
            Returns the number of slices in the spread
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Item(System.Int32)">
            <summary>
            Returns the item at the specified index. Can throw ArgumentOutOfRangeException exception
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Collections.Spread">
            <summary>
            Contains all those methods which are used in C# and VL.
            Methods which are only used in VL reside in SpreadNodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.SizeInBytes``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            The size in bytes = element type size * count.
            Returns IntPtr * count for reference types.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.GetInternalArray``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            Gets the internal data array of the spread, use at your own risk, i.e. never modify it.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.AsSpreadUnsafe``1(``0[])">
            <summary>
            Interprets the array as a spread. The array must not mutate after this call or the immutability of the spread is violated.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpreadBuilder">
            <summary>
            Non-generic view on spread builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ISpreadBuilder.ToSpread">
            <summary>
            Returns an immutable spread of the current contents of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at specified index
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies 'Count' elements from 'Start Index' to an Array at the 'Array Index' position
            </summary>
            <param name="array"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="arrayIndex"></param>
            <param name="reverseOrder"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            Removes all the elements that match the conditions defined by the specified predicate.
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort">
            <summary>
            Sorts the elements in the entire spread builder using the default comparer
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in the entire spread builder using the specified comparer function
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.HoldLatestCopy">
            <summary>
            Holds on to a copy of the latest received image. Whenever an image gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageExtensions.Default">
            <summary>
            A white one by one pixel RGBA image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.ReadOnlyMemory{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.String,System.Boolean)">
            <summary>
            Makes the array accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided array is only valid in the current call stack.</param>
            <returns>An image which uses the array as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.String)">
            <summary>
            Makes the spread accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>An image which uses the spread as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.String,System.Boolean)">
            <summary>
            Tries to fetch the backing memory of the given <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and makes its data accessible as an image. No data gets copied. 
            In case the data can't be accessed as a <see cref="T:System.ReadOnlyMemory`1"/> the default image will be returned.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image using the given data as its backing store or the default image if backing memory couldn't be fetched.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(System.ReadOnlyMemory{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.String,System.Boolean)">
            <summary>
            Makes the memory accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not provided memory is only valid in the current call stack.</param>
            <returns>An image which uses the given memory as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.Drawing.Bitmap,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Makes the bitmap accessible as an image. No data gets copied.
            </summary>
            <param name="bitmap">The bitmap to wrap.</param>
            <param name="takeOwnership">Whether or not the wrapper should take ownership of the bitmap. So in case it gets disposed the bitmap will also get disposed.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the bitmap gets modified later.</param>
            <param name="canWrite">Whether or not one can write into the bitmap.</param>
            <returns>The image wrapping the bitmap.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.IntPtr,System.Int32,System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the pointer accessible as an image. No data gets copied. The returned image is volatile and should get disposed of.
            Once disposed further access to <see cref="M:VL.Lib.Basics.Imaging.IImage.GetData"/> will return the image data from the default image.
            </summary>
            <param name="pointer">The pointer to the data of the image.</param>
            <param name="size">The size in bytes of the image data.</param>
            <param name="width">The width in pixel.</param>
            <param name="height">The height in pixel.</param>
            <param name="format">The pixel format.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>A volatile image using the pointer as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.Clone(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CloneEmpty(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates an empty clone of the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>An image of the same size and format but with all pixels set to zero.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.AsNewImage(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates a new image instance without copying any data. Useful to propagate changed information.
            </summary>
            <param name="image">The image to "re-sell" as a new image.</param>
            <returns>A new image instance reusing all the data of the input image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.HasSameInfo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Whether or not the image info is the same.
            </summary>
            <param name="image">The image.</param>
            <param name="other">The other image to compare the info with.</param>
            <returns>True if the image info is the same</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage@)">
            <summary>
            Copies the source image to the destination location. If the destination is not yet assigned or if the image
            information doesn't fit a new image will be created and assigned to the destination.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The destination location to copy the image to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Copies the source image to the destination image. The source and destination images must have the same format.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The image to copy to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToStream(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Makes the image accessible as a stream.
            </summary>
            <param name="image">The image to wrap.</param>
            <returns>A stream which will read from the image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.IImageData)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="dstData">The destination image data.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.FromImage(VL.Lib.Basics.Imaging.IImage,System.Boolean)">
            <summary>
            Makes the <see cref="T:VL.Lib.Basics.Imaging.IImage"/> accessible as a <see cref="T:System.Drawing.Bitmap"/> by either copying the pixels or wrapping them.
            </summary>
            <param name="image">The image to either copy the pixels from or wrap in a <see cref="T:System.Drawing.Bitmap"/>.</param>
            <param name="copy">Whether or not to copy the pixels.</param>
            <returns>The <see cref="T:System.Drawing.Bitmap"/> containing either the copied pixels or pointing to the upstream image data.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.GetPixelSize(VL.Lib.Basics.Imaging.PixelFormat)">
            <summary>
            Gets the pixel size in bytes.
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ImageInfo">
            <summary>
            A structure containing size information of an image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Width">
            <summary>
            The width of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Height">
            <summary>
            The height of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Format">
            <summary>
            The pixel format of the image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.IsPremultipliedAlpha">
            <summary>
            Whether or not the color channels are premultiplied with the alpha value.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.OriginalFormat">
            <summary>
            The original pixel format as defined by the library the image was loaded from.
            Can be used in case the <see cref="F:VL.Lib.Basics.Imaging.ImageInfo.Format"/> property is set to <see cref="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.Boolean,System.Int32,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="isPremultipliedAlpha">Are the color channels pre-multiplied with the alpha value.</param>
            <param name="scanSize">The size of one scan line (row of pixels) in bytes.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.Split(System.Int32@,System.Int32@,VL.Lib.Basics.Imaging.PixelFormat@,System.String@)">
            <summary>
            Splits the image info up into its components.
            </summary>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The original format string (if any) of the image.</param>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.PixelSize">
            <summary>
            The size of a pixel in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ImageSize">
            <summary>
            The size of the image in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ScanSize">
            <summary>
            The size of one scan line (row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ArrayImage`1">
            <summary>
            Image implementation using an array as backing store.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.BitmapImage">
            <summary>
            Image implementation using a <see cref="T:System.Drawing.Bitmap"/> as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IntPtrImage">
            <summary>
            Image implementation using unmanaged memory as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImage">
            <summary>
            Gives read-only access to images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.Info">
            <summary>
            A structure containing size and format information of the image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.IImage.GetData">
            <summary>
            Gives access to image's data. Must be disposed after being used.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.IsVolatile">
            <summary>
            A volatile image is only valid in the current call stack.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImageData">
            <summary>
            Used for reading images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Bytes">
            <summary>
            Gets the pixel data.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.ScanSize">
            <summary>
            The scan size (one row of pixels including padding) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PixelFormat">
            <summary>
            An enumeration of commonly used pixel formats.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown">
            <summary>
            Unkown pixel format.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8">
            <summary>
            A single-component, 8-bit unsigned-normalized-integer format that supports 8 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R16">
            <summary>
            A single-component, 16-bit unsigned-normalized-integer format that supports 16 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32F">
            <summary>
            A single-component, 32-bit floating-point format that supports 32 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8">
            <summary>
            24-bit RGB pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8">
            <summary>
            24-bit BGR pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8X8">
            <summary>
            32-bit RGBx pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8A8">
            <summary>
            32-bit RGBA pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8X8">
            <summary>
            32-bit BGRx pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8A8">
            <summary>
            32-bit BGRA pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32B32A32F">
            <summary>
            128-bit RGBA floating point pixel format using 32 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32F">
            <summary>
            A two-component, 64-bit floating-point format using 32 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R16G16B16A16F">
            <summary>
            64-bit RGBA floating point pixel format using 16 bits for each channel.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IRefCounter`1">
            <summary>
            Abstraction used by <see cref="T:VL.Lib.Basics.Resources.Using`1"/> and <see cref="T:VL.Lib.Basics.Resources.Producing`1"/> to enable reference counting on specific resources.
            </summary>
            <typeparam name="T">The resource type</typeparam>
        </member>
        <member name="M:VL.Lib.Basics.Resources.IRefCounter`1.Init(`0)">
            <summary>
            Sets the reference count on the resource to one.
            Throws <see cref="T:System.InvalidOperationException"/> in case reference counting is already unlocked on the resource.
            </summary>
            <remarks>
            Must only be called by producers.
            </remarks>
            <param name="resource">The resource whose reference count shall be one</param>
        </member>
        <member name="M:VL.Lib.Basics.Resources.IRefCounter`1.AddRef(`0)">
            <summary>
            Increases the referece count on the resource (if reference counting is available).
            </summary>
            <param name="resource">The resource whose reference count shall be increased</param>
        </member>
        <member name="M:VL.Lib.Basics.Resources.IRefCounter`1.Release(`0)">
            <summary>
            Decreases the reference count on the resource (if reference counting is available).
            </summary>
            <param name="resource">The resource whose reference count shall be decreaed</param>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Using`1">
            <summary>
            Keeps the given resource alive by increasing its reference count.
            It will only do so if reference counting was indeed made available by a <see cref="T:VL.Lib.Basics.Resources.Producing`1"/> node.
            </summary>
            <remarks>
            Internally two references are kept called front and back. The setter uses the back reference, while the getter swaps front and back in case
            a new resource has been set. This ensures that the latest retrieved resource will be alive even when a new one gets set on another thread.
            The two references also ensure that a resource doesn't get released too early during a frame.
            </remarks>
            <typeparam name="T">The type of the resource.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Producing`1">
            <summary>
            Manages the lifetime of a resource through reference counting (if available for the specific resource type).
            </summary>
            <remarks>
            A <seealso cref="T:VL.Lib.Basics.Resources.IRefCounter`1"/> must be registered for the resource type to unlock its reference counting.
            </remarks>
            <typeparam name="T">The type of the resource.</typeparam>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.UsingAsync``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetch a resource, use it, let it get disposed of when the Task is done.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.ToObservable``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetches a resource and fires a result when the worker task is done. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool. Check the Cancelation token in your worker to stop work if cancelation was requested.
            </summary>        
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceProvider`1">
            <summary>
            Provides an IResourceHandle, which provides access to a Disposable resource.
            Consumers need to dispose these Handles.
            Implementations provide mechanisms for distributing and sharing Disposable resources.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceHandle`1">
            <summary>
            Is returned by IResourceProvider.GetHandle().
            Provides access to a Disposable Resource.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IConnectableResourceProvider`1">
            <summary>
            A connectable resource provider only works after calling Connect. 
            Disconnect via the disposable returned by Connect(). Only then the upstream handle gets disposed of.
            Used to share Resources more efficiently while connected.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledInternal``2(System.Collections.Generic.Dictionary{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="pool">The pool to use</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(VL.Core.NodeContext,``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">Unused parameter which was fed by VL. Used to figure out which app this node is in.</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(VL.Core.NodeContext,``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">Unused parameter which was fed by VL. Used to figure out which app this node is in.</param>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(VL.Core.NodeContext,System.Func{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">Unused parameter which was fed by VL. Used to figure out which app this node is in.</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(System.Func{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(VL.Core.NodeContext,System.Func{``0},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="nodeContext">Unused parameter which was fed by VL. Used to figure out which app this node is in.</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledPerApp``1(System.Func{``0},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledSystemWide``2(``0,System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooledSystemWide``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource provider from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0},System.Action{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Return``1(``0)">
            <summary>
            Will always provide same single resource. It exists already. 
            So its not the responsibility of Return() to dispose it.
            
            Could also imagine a ReturnLazy that takes a Func&lt;TResource&gt;, 
            but as it is used mostly inside the monade it is already lazy to GetHandle() from downstream
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}})">
            <summary>
            SelectMany
            Create a ResourceProvider per source resource. Creating any provider will work.
            Takes into account that the resulting resources may depend on the source resources.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will not get managed as it may exist already. (Select(form => form.Controls[0]) should not dispose the control)
            If you create a new resource that you want to get managed use BindNew for this.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a new resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will get managed.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Do``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Applies an action on a resource and outputs the same resource again.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Where``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Just doesn't let you access a resource that doesn't match your needs. Gives you default instead.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.PublishPooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            Manages a pool of handles from the upstream provider.
            On GetHandle, this will return a Handle containing a resource that is not currently in use.
            Manages a pool of upstream handles. When a downstream handle gets disposed, it's inner upstream Handle will be put back into the pool.
            
            Will dispose every upstream handle still in the pool on disconnect.
            Former disposable provider Pool
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``1(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.Int32)">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After delayDisposalInMilliseconds, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``2(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After disposalTriggerSource fired, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Serialize``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Handles get handed out in a serial fashion. Only one handle is in circulation at a given point in time.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32)">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify how long the resource stays valid after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify how long the resource stays valid. 
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify how long the resources in the pool stay valid after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Cata
            Empty using statement
            Only use for sideeffects of the upstream ResourceProvider Monad
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Cata
            Runs the action on the resource
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Cata
            Runs the extractor on the resource and returns the output.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``3(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Return a resource using two source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Return a resource using three source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Return a resource using four source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new resource using three source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new resource using four source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Finally``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Act on the resource right before it gets disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Handle`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Provider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.ConnectableProvider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable returned by Connect().
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.GetLatestResourceForTemporaryUse`1">
            <summary>
            Takes a resourceprovider and outputs its resource
            Makes sure to call GetHandle before releasing the old handle.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsFile">
            <summary>
            Returns whether the path is a file
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsDirectory">
            <summary>
            Returns whether the path is a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsRooted">
            <summary>
            Whether the path string contains a root.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Root">
            <summary>
            Returns the root path (if any).
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Size">
            <summary>
            Returns the size of a file or all the files in a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Exists">
            <summary>
            Returns whether file or folder exists
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.Refresh">
            <summary>
            Updates all properties of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.IO.Path.Parent">
            <summary>
            For a directory returns its parent directory. For a file returns the directory the file is in
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDescendants(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files and folders contained withinin a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDirectories(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all folders contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetFiles(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.Filename(System.String@,System.String@,System.String@)">
            <summary>
            Returns the directory path and the name and extension of a file
            </summary>
            <param name="directory"></param>
            <param name="filename"></param>
            <param name="extension"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.GetAttributes(System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.SetAttributes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.Modified(System.DateTime@,System.DateTime@,System.DateTime@)">
            <summary>
            Returns creation date, last write and last access dates of a file or folder
            </summary>
            <param name="creationTime"></param>
            <param name="lastWriteTime"></param>
            <param name="lastAccessTime"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeRelative(VL.Lib.IO.Path)">
            <summary>
            Returns this absolute path as a relative path to the given base path.
            In case the base path has a different root than this path or this path is relative already 
            the same path will be returned.
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeAbsolute(VL.Lib.IO.Path)">
            <summary>
            Returns this relative path as an absolute path to the given base path.
            In case this path is absolute already the same path will be returned.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.Permutations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            (a,b),(c,d) -> (a,c),(a,d),(b,c),(b,d)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetArray``1(System.Collections.Generic.IEnumerable{``0},``0[]@)">
            <summary>
            Tries to fetch the underlying array from the given sequence. Tests for array, <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> and <see cref="T:VL.Lib.Collections.Spread`1"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="array">The underlying array.</param>
            <returns>True if the array could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetArraySegment``1(System.Collections.Generic.IEnumerable{``0},System.ArraySegment{``0}@)">
            <summary>
            Tries to fetch the underlying array segment from the given sequence. Tests for array, <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> and <see cref="T:VL.Core.IHasMemory`1"/>.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="segment">The underlying array segment.</param>
            <returns>True if the array segment could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetMemory``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlyMemory{``0}@)">
            <summary>
            Tries to fetch the backing memory of the provided sequence. Tests for collections implementing <see cref="T:VL.Core.IHasMemory`1"/>, 
            array and <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <typeparam name="T">The elment type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="memory">The content of the sequence as memory.</param>
            <returns>True if the memory could be fetched.</returns>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.TryGetSpan``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{``0}@)">
            <summary>
            Tries to expose the sequence as a <see cref="T:System.ReadOnlySpan`1"/>. Tests for collections implementing <see cref="T:VL.Core.IHasMemory`1"/>, 
            array and <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <typeparam name="T">The elment type.</typeparam>
            <param name="sequence">The sequence to test.</param>
            <param name="span">The content of the sequence exposed as a span.</param>
            <returns>True if the content could be exposed as a span.</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions1.EnsureValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            create the value if not already stored for that key
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtIfNotEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            throws if input is empty. so please check that first
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtOrDefault``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            if count = 0 returns a default(T)
            </summary>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableStackExtensions.SequenceEqual``1(System.Collections.Immutable.ImmutableStack{``0},System.Collections.Immutable.ImmutableStack{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Same as <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/> but without any memory allocations when enumerating the stacks.
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
            <summary>
            Returns the bounds of the given point cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.RectangleF})">
            <summary>
            Returns the bounds of the given rectangle cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Area(System.Drawing.SizeF)">
            <summary>
            Returns the area.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetCenter(System.Drawing.RectangleF)">
            <summary>
            Returns the center of this RectangleF.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetOnePixelRectangleForCenter(System.Drawing.PointF)">
            <summary>
            Returns a rectangle for given center position and 1 pixel size
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetRectangleForCenterAndSize(System.Drawing.PointF,System.Drawing.SizeF)">
            <summary>
            Returns a rectangle for given center position and size.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToRectangle(System.Drawing.RectangleF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Rectangle">Rectangle</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToPoint(System.Drawing.PointF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Point">Point</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Plus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Minus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetSquaredDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the squared distance to another point. Good for comparisons.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Normalize(System.Drawing.PointF)">
            <summary>
            Normalizes the length
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformPoint(System.Drawing.Drawing2D.Matrix,System.Drawing.PointF)">
            <summary>
            Applies the transformation to a PointF
            </summary>
            <param name="t">A Matrix</param>
            <param name="p">The point to transform by the matrix t</param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.Rectangle)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.RectangleF)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
        <member name="T:System.SyncProgress`1">
            <summary>
            Provides an IProgress{T} that invokes callbacks for each reported progress value synchronously without using a synchronization context.
            See: https://stackoverflow.com/questions/37883297/can-i-await-on-iprogress-report
            </summary>
            <typeparam name="T">Specifies the type of the progress report value.</typeparam>
            <remarks>
            Any handler provided to the constructor or event handlers registered with
            the <see cref="E:System.SyncProgress`1.ProgressChanged"/> event are invoked synchronously by the caller.
            </remarks>
        </member>
        <member name="F:System.SyncProgress`1.m_handler">
            <summary>The handler specified to the constructor.  This may be null.</summary>
        </member>
        <member name="F:System.SyncProgress`1.m_invokeHandlers">
            <summary>A cached delegate used to post invocation to the synchronization context.</summary>
        </member>
        <member name="M:System.SyncProgress`1.#ctor">
            <summary>Initializes the <see cref="T:System.SyncProgress`1"/>.</summary>
        </member>
        <member name="M:System.SyncProgress`1.#ctor(System.Action{`0})">
            <summary>Initializes the <see cref="T:System.SyncProgress`1"/> with the specified callback.</summary>
            <param name="handler">
            A handler to invoke for each reported progress value.  This handler will be invoked
            in addition to any delegates registered with the <see cref="E:System.SyncProgress`1.ProgressChanged"/> event.
            Depending on the <see cref="T:System.Threading.SynchronizationContext"/> instance captured by 
            the <see cref="!:Progress"/> at construction, it's possible that this handler instance
            could be invoked concurrently with itself.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="handler"/> is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="E:System.SyncProgress`1.ProgressChanged">
            <summary>Raised for each reported progress value.</summary>
            <remarks>
            Handlers registered with this event will be invoked on the 
            <see cref="T:System.Threading.SynchronizationContext"/> captured when the instance was constructed.
            </remarks>
        </member>
        <member name="M:System.SyncProgress`1.OnReport(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.SyncProgress`1.System#IProgress{T}#Report(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.SyncProgress`1.InvokeHandlers(System.Object)">
            <summary>Invokes the action and event callbacks.</summary>
            <param name="state">The progress value.</param>
        </member>
    </members>
</doc>
